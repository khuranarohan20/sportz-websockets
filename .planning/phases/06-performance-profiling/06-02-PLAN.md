---
phase: 06-performance-profiling
plan: 02
type: execute
---

<objective>
Profile database operations and identify performance bottlenecks in queries and connection pooling.

Purpose: Understand database performance characteristics before optimization work. Identify slow queries, connection pool exhaustion, and N+1 query patterns.
Output: Database profiling report with query performance metrics and bottleneck identification.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-performance-profiling/06-RESEARCH.md
@server/src/db/db.ts
@server/src/db/schema.ts
@server/src/routes/matches.ts
@server/src/routes/commentary.ts
@server/profiling/BASELINE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enable pg_stat_statements extension in Neon</name>
  <files>server/profiling/enable-pg-stat-statements.sql, server/profiling/06-02-setup.log</files>
  <action>
    Enable PostgreSQL's pg_stat_statements extension for query performance tracking:

    1. Create setup script server/profiling/enable-pg-stat-statements.sql:
       ```sql
       -- Enable pg_stat_statements extension
       CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

       -- Verify installation
       SELECT *
       FROM pg_available_extensions
       WHERE name = 'pg_stat_statements';

       -- Check current stats (should be empty initially)
       SELECT count(*) as query_count
       FROM pg_stat_statements;
       ```

    2. Connect to Neon database and execute:
       psql $DATABASE_URL -f server/profiling/enable-pg-stat-statements.sql

    3. Capture output to server/profiling/06-02-setup.log

    4. Verify the extension is active by querying pg_stat_statements view

    Note: Neon Postgres typically supports pg_stat_statements. If extension creation fails with "shared_preload_libraries" error, document the limitation in the log file - Neon may require a different approach.
  </action>
  <verify>File 06-02-setup.log shows pg_stat_statements extension created successfully OR documents Neon-specific limitation</verify>
  <done>pg_stat_statements extension enabled and verified ready for query profiling</done>
</task>

<task type="auto">
  <name>Task 2: Profile database operations under load</name>
  <files>server/profiling/06-02-database-profile.md, server/profiling/query-profile.sql</files>
  <action>
    Profile database performance while running load tests:

    1. Create query analysis script server/profiling/query-profile.sql:
       ```sql
       -- Reset statistics before profiling
       SELECT pg_stat_statements_reset();

       -- After load tests, find slowest queries
       SELECT
         LEFT(query, 80) as query_sample,
         calls,
         total_exec_time as total_ms,
         mean_exec_time as avg_ms,
         stddev_exec_time as stddev_ms,
         max_exec_time as max_ms,
         rows
       FROM pg_stat_statements
       WHERE dbid = (SELECT oid FROM pg_database WHERE datname = current_database())
       ORDER BY mean_exec_time DESC
       LIMIT 20;

       -- Find most frequently called queries
       SELECT
         LEFT(query, 80) as query_sample,
         calls,
         total_exec_time / calls as avg_ms
       FROM pg_stat_statements
       ORDER BY calls DESC
       LIMIT 20;
       ```

    2. Start server in one terminal

    3. In second terminal, reset stats and start load test:
       ```bash
       psql $DATABASE_URL -c "SELECT pg_stat_statements_reset();"
       node load-tests/run-performance-tests.js
       ```

    4. After load tests complete, capture query profiles:
       ```bash
       psql $DATABASE_URL -f server/profiling/query-profile.sql > server/profiling/06-02-database-profile.md
       ```

    5. Document findings in 06-02-database-profile.md including:
       - Top 10 slowest queries by average execution time
       - Top 10 most frequently called queries
       - Any queries with high standard deviation (inconsistent performance)
       - Total database time across all operations

    This reveals which database operations are bottlenecks.
  </action>
  <verify>File 06-02-database-profile.md exists with slowest queries list, most frequent queries list, and performance analysis</verify>
  <done>Database operations profiled under load, slow queries identified</done>
</task>

<task type="auto">
  <name>Task 3: Analyze connection pool behavior and identify bottlenecks</name>
  <files>server/src/db/db.ts, server/profiling/06-02-bottlenecks.md</files>
  <action>
    Analyze database connection pool configuration and behavior:

    1. Check current pool configuration in server/src/db/db.ts:
       - Look for Pool constructor options (max, min, idleTimeoutMillis)
       - Document current pool size limits
       - Check connection timeout settings

    2. Review Drizzle ORM usage for patterns that could cause pool exhaustion:
       - Check server/src/routes/matches.ts for query patterns
       - Check server/src/routes/commentary.ts for query patterns
       - Look for N+1 queries (loops that execute queries)
       - Look for transactions held open too long

    3. Correlate with baseline metrics from server/profiling/BASELINE.md:
       - Compare database write performance (~40-50 req/sec) with pool limits
       - Check if pool exhaustion explains the bottleneck
       - Identify if connection acquisition time is significant

    4. Create bottleneck report server/profiling/06-02-bottlenecks.md:
       - **Connection Pool Analysis**: Current config, observed behavior under load
       - **Query Pattern Issues**: N+1 queries, missing indexes, inefficient patterns
       - **Correlation with Baseline**: How database performance affects HTTP endpoint performance
       - **Recommendations for Phase 7**: What to optimize (pool size, queries, schema)

    This report guides optimization work in Phase 7.
  </action>
  <verify>File 06-02-bottlenecks.md exists with connection pool analysis, query pattern issues, baseline correlation, and optimization recommendations</verify>
  <done>Database bottlenecks identified and documented with Phase 7 optimization recommendations</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] pg_stat_statements extension enabled (or limitation documented)
- [ ] Database operations profiled under load
- [ ] Query performance metrics captured (slowest, most frequent)
- [ ] Connection pool analysis completed
- [ ] Bottleneck report created with Phase 7 recommendations
</verification>

<success_criteria>
- pg_stat_statements extension configured for query tracking
- Database query performance profiled under realistic load
- Connection pool behavior analyzed
- Performance bottlenecks identified with specific recommendations
- Report ready to guide Phase 7 optimization work
</success_criteria>

<output>
After completion, create `.planning/phases/06-performance-profiling/06-02-SUMMARY.md`:

# Phase 6 Plan 2: Database Profiling Summary

**Profiled database operations and identified query and connection pool bottlenecks.**

## Accomplishments

- Enabled pg_stat_statements for query performance tracking
- Profiled database under load with comprehensive query metrics
- Analyzed connection pool behavior and configuration
- Identified specific bottlenecks with optimization recommendations

## Files Created/Modified

- `server/profiling/enable-pg-stat-statements.sql` - Extension setup
- `server/profiling/query-profile.sql` - Query analysis script
- `server/profiling/06-02-database-profile.md` - Query performance metrics
- `server/profiling/06-02-bottlenecks.md` - Bottleneck analysis

## Key Findings

- [Slowest queries identified with execution times]
- [Connection pool configuration and behavior]
- [N+1 query patterns or schema issues]
- [Correlation with HTTP endpoint performance]

## Next Step

Ready for 06-03-PLAN.md (WebSocket Profiling)
</output>
