---
phase: 03-core-application-types
plan: 03
type: execute
---

<objective>
Convert utility functions, helper modules, and constants to TypeScript with proper type annotations.

Purpose: Complete the core application type conversion by typing all utility functions, match status logic, and application constants.
Output: Fully typed `server/src/utils/` and `server/src/constants/` directories.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/STACK.md
@.planning/codebase/STRUCTURE.md
@.planning/phases/01-typescript-foundation/01-01-SUMMARY.md
@.planning/phases/01-typescript-foundation/01-02-SUMMARY.md
@.planning/phases/01-typescript-foundation/01-03-SUMMARY.md
@server/src/utils/match-status.js
@server/src/constants/match.js
@server/src/constants/arcjet.js
@server/src/constants/ws.js
@server/src/validation/matches.js

**Tech stack available from Phase 1:**
- TypeScript 5.9.3 with strict type checking
- ES2022 target with modern JavaScript features
- No any types allowed (strict null checks enabled)

**Established patterns from Phase 1:**
- Pattern 1: No any types allowed
- Pattern 2: Explicit return types for functions
- Pattern 3: Strict null checking means handling null/undefined explicitly

**Assuming Phase 2 completed:**
- Match status enum type available from database schema inference

**Key files to reference:**
- server/src/utils/match-status.js - Match status calculation logic
- server/src/constants/match.js - Match-related constants
- server/src/constants/arcjet.js - Arcjet rule constants
- server/src/constants/ws.js - WebSocket configuration constants
- server/src/validation/matches.js - MATCH_STATUS enum (will be .ts after Phase 4)

**Constraining decisions from Phase 1:**
- Must handle null returns explicitly (strictNullChecks enabled)
- Must type all function parameters and return values
- Must use Date constructor type checking for date validation

**Context from match-status.js:**
- getMatchStatus returns null if dates are invalid (NaN)
- syncMatchStatus is async and updates match status
- Imports MATCH_STATUS enum from validation/matches.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert match-status.js to match-status.ts with function type annotations</name>
  <files>server/src/utils/match-status.ts</files>
  <action>Rename server/src/utils/match-status.js to server/src/utils/match-status.ts. Add comprehensive type annotations:
  - Create local MatchStatus type: `type MatchStatus = 'scheduled' | 'live' | 'finished'` (temporary - will use database type after Phase 4)
  - Type `getMatchStatus` parameters: `startTime: string | Date`, `endTime: string | Date`, `now?: Date`
  - Type `getMatchStatus` return value: `MatchStatus | null` (returns null for invalid dates)
  - Type `syncMatchStatus` parameters: `match: { status: MatchStatus, startTime: string | Date, endTime: string | Date }`, `updateStatus: (status: MatchStatus) => Promise<void>`
  - Type `syncMatchStatus` return value: `Promise<MatchStatus>`
  - Import MATCH_STATUS from validation/matches.js as .ts extension (will be converted in Phase 4)
  - Add proper type guards for Date validation: `start instanceof Date` and `end instanceof Date`
  - Use `Number.isNaN()` for NaN checking (already correct, just type it properly)
  No logic changes - only type annotations added.</action>
  <verify>npm run type-check passes for match-status.ts, all function types properly annotated</verify>
  <done>match-status.ts renamed, all functions typed with explicit parameters and return types</done>
</task>

<task type="auto">
  <name>Task 2: Convert constants files to TypeScript with proper types</name>
  <files>server/src/constants/match.ts, server/src/constants/arcjet.ts, server/src/constants/ws.ts</files>
  <action>Rename all constants files from .js to .ts and add type annotations:
  - Rename match.js → match.ts: Type MAX_MATCH_QUERY_LIMIT as `const MAX_MATCH_QUERY_LIMIT: 100`
  - Rename arcjet.js → arcjet.ts: Add interface for Arcjet rules with `interface ArcjetRules { INTERVAL: string; MAX: number }`, then type HTTP_ARCJECT_RULES and WS_ARCJECT_RULES as `ArcjetRules`
  - Rename ws.js → ws.ts: Type MAX_PAYLOAD_SIZE and PING_PONG_INTERVAL as `const` with inferred number types (can use `as const` for literal types if desired)
  - Use TypeScript's const assertion feature for stricter literal typing where appropriate
  - All constants are already properly typed by inference, add explicit types only where they add clarity
  No logic changes - constants remain the same values.</action>
  <verify>npm run type-check passes for all constants files, TypeScript compiler infers correct types</verify>
  <done>All three constants files renamed to .ts, properly typed with interfaces or const assertions</done>
</task>

<task type="auto">
  <name>Task 3: Update import paths across codebase to use .ts extensions for utils and constants</name>
  <files>server/src/config/arcjet.ts, server/src/utils/match-status.ts</files>
  <action>Update import statements to use .ts extensions:
  - In server/src/config/arcjet.ts: Change `../constants/arcjet.js` to `../constants/arcjet.ts`
  - In server/src/utils/match-status.ts: Change `../validation/matches.js` to `../validation/matches.ts` (will exist after Phase 4)
  - Verify all import paths resolve correctly with TypeScript compiler
  - Note: Some imports may reference files not yet converted (like validation/matches.ts) - that's expected
  - Run TypeScript compiler to ensure module resolution works
  Fix any import path issues that arise.</action>
  <verify>npm run type-check passes, all import paths use .ts extensions where files exist</verify>
  <done>All imports to utils/ and constants/ use .ts extensions, module resolution successful</done>
</task>

</tasks>

<verification>
Before declaring this plan complete:
- [ ] `npm run type-check` passes with no errors in utils/ and constants/
- [ ] `npm run lint` passes with no errors in utils/ and constants/
- [ ] server/src/utils/match-status.ts is valid TypeScript
- [ ] server/src/constants/match.ts is valid TypeScript
- [ ] server/src/constants/arcjet.ts is valid TypeScript
- [ ] server/src/constants/ws.ts is valid TypeScript
- [ ] All import statements use .ts extensions
- [ ] No any types used in type annotations
</verification>

<success_criteria>

- All .js files in utils/ renamed to .ts
- All .js files in constants/ renamed to .ts
- Function parameters and return values explicitly typed
- Constants have proper TypeScript types
- Match status utility handles null returns correctly
- Import paths use .ts extensions
  </success_criteria>

<output>
After completion, create `.planning/phases/03-core-application-types/03-03-SUMMARY.md`:

# Phase 3 Plan 3: Utility Functions & Constants Summary

**Converted utility functions, helpers, and constants to TypeScript.**

## Accomplishments

- Renamed and typed match-status.ts with comprehensive function annotations
- Renamed and typed all three constants files (match.ts, arcjet.ts, ws.ts)
- Added interface for Arcjet rules configuration
- Updated all import paths to .ts extensions

## Files Created/Modified

- `server/src/utils/match-status.ts` - Converted from JavaScript
- `server/src/constants/match.ts` - Converted from JavaScript
- `server/src/constants/arcjet.ts` - Converted from JavaScript
- `server/src/constants/ws.ts` - Converted from JavaScript
- `server/src/config/arcjet.ts` - Updated import path
- `server/src/utils/match-status.ts` - Updated import path

## Decisions Made

- Created local MatchStatus type (temporary - will use database type after Phase 4)
- Used interface for Arcjet rules for better documentation
- Kept match status enum import from validation (will be typed in Phase 4)
- Explicitly handled null return type for invalid dates (strict null checking)

## Issues Encountered

None

## Deviations from Plan

None

## Next Phase Readiness

**Phase 3 complete.** All Core Application Types work finished:
- ✅ Express app setup and server initialization typed (03-01)
- ✅ Configuration and environment handling typed (03-02)
- ✅ Utility functions and constants typed (03-03)

The project is ready to begin converting API routes and middleware to TypeScript in Phase 4 (04-01-PLAN.md).

### Type Safety Achieved

Core application infrastructure now has full type safety:
- Main server entry point (index.ts) - Express and HTTP types
- Configuration files (config/) - Arcjet and environment types
- Utility functions (utils/) - Function parameters and return values
- Constants (constants/) - Properly typed configuration values

All files follow the strict type checking policy established in Phase 1 with no any types.
</output>
