---
phase: 02-database-schema-types
plan: 02
type: execute
---

<objective>
Type database connection and ORM operations with explicit type annotations for full type safety.

Purpose: Enable type-safe database queries throughout the application by adding explicit types to the Drizzle client.
Output: Fully typed database client in `src/db/db.ts` with exported query types.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-database-schema-types/DISCOVERY.md
@.planning/phases/02-database-schema-types/02-01-SUMMARY.md
@.planning/phases/01-typescript-foundation/01-01-SUMMARY.md
@server/src/db/db.js
@server/src/db/schema.ts

**Tech stack available:**
- typescript@5.9.3 (from Phase 1)
- drizzle-orm@0.45.1 (TypeScript-native)
- pg@8.18.0 (includes built-in types)
- @types/node@25.2.3 (from Phase 1)

**Established patterns:**
- Custom types go in src/types/ directory (Phase 1)
- No any types allowed (Phase 1 strict type checking)
- ES2022 target with bundler module resolution (Phase 1)

**Constraining decisions:**
- Phase 1: Strict type checking enabled - db client must be explicitly typed
- Phase 2-01: Schema types already exported (Match, NewMatch, Commentary, NewCommentary)
- Discovery: Use Drizzle's type inference, don't hand-roll types

**Discovery findings:**
- Drizzle client should be typed: `drizzle<Pool>(pool)` for full type safety
- Automatic query result typing when schemas are TypeScript
- pg package includes built-in types - no @types/pg needed
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rename db.js to db.ts and add type annotation to Drizzle client</name>
  <files>server/src/db/db.js, server/src/db/db.ts</files>
  <action>Rename server/src/db/db.js to server/src/db/db.ts. Add explicit type annotation to the drizzle client: change `export const db = drizzle(pool);` to `export const db = drizzle<Pool>(pool);`. Import Pool type from 'pg': `import type { Pool } from 'pg';`. This enables full type inference for all database queries.

The pool and DATABASE_URL validation code remain unchanged - they already work with TypeScript.</action>
  <verify>Run `cd server && npm run type-check` - should pass with no errors. Verify db.ts exists and imports Pool type correctly.</verify>
  <done>File renamed, Drizzle client has explicit Pool type annotation, compilation succeeds</done>
</task>

<task type="auto">
  <name>Task 2: Export query builder types for use in routes</name>
  <files>server/src/db/schema.ts, server/src/db/db.ts</files>
  <action>In schema.ts, export query builder types that routes will use for type-safe queries:
- Export the matches table itself: `export { matches }` (already exported)
- Export the commentary table itself: `export { commentary }` (already exported)

Then in db.ts, re-export the inferred types for convenience:
- `export type { Match, NewMatch, Commentary, NewCommentary } from './schema.js';`

This creates a single import point for all database types. Routes will import types like `import type { Match, NewMatch } from '../db/db.js';`</action>
  <verify>Run `cd server && npm run type-check` - should pass. Inspect both files to confirm exports are present.</verify>
  <done>Query builder and table types exported from db.ts, available for route imports</done>
</task>

<task type="auto">
  <name>Task 3: Verify type inference works with sample query patterns</name>
  <files>server/src/db/db.ts</files>
  <action>Create a temporary test to verify type inference works correctly. Add a comment block in db.ts demonstrating the type safety:
```typescript
// Type inference examples:
// const allMatches: Match[] = await db.select().from(matches);
// const newMatch: NewMatch = { sport: 'basketball', homeTeam: 'Lakers', awayTeam: 'Warriors', startTime: new Date() };
// await db.insert(matches).values(newMatch);
```
Don't execute these queries - they're documentation showing how the types will be used in Phase 4 (routes conversion).</action>
  <verify>Run `cd server && npm run type-check` - comments shouldn't affect compilation. No code execution needed.</verify>
  <done>Type inference documented with examples, compilation succeeds</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd server && npm run type-check` passes with no errors
- [ ] `cd server && npm run build` compiles successfully
- [ ] db.ts file exists with typed Drizzle client
- [ ] Type exports re-exported from db.ts
- [ ] Type inference examples documented
</verification>

<success_criteria>

- Database connection and client fully typed
- Query builder types exported for use in routes
- Type inference verified with documented examples
- No TypeScript compilation errors
- Zero functional changes - database operations work identically
</success_criteria>

<output>
After completion, create `.planning/phases/02-database-schema-types/02-02-SUMMARY.md`:

# Phase 2 Plan 2: Database Client Typing Summary

**Added explicit type annotations to database client and exported query types.**

## Accomplishments

- Converted db.js to db.ts with typed Drizzle client
- Exported query builder and table types from db.ts
- Documented type inference patterns for route handlers

## Files Created/Modified

- `server/src/db/db.ts` - Converted from .js, added Pool type annotation, re-exports schema types

## Decisions Made

[Document any decisions made during execution]

## Issues Encountered

[Document any problems and resolutions, or "None"]

## Next Step

Ready for 02-03-PLAN.md (Type-safe database migrations and utilities)
</output>
