---
phase: 05-websocket-realtime
type: execute
plan: 02
---

<objective>
Add type safety to WebSocket message protocols and subscription contracts.

Purpose: Define TypeScript types for all WebSocket messages exchanged between client and server, ensuring type-safe real-time communication.

Output: Message type definitions, validated client-server protocols, and typed WebSocket contracts.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/phase-prompt.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Auto-selected based on dependency graph (from frontmatter):
@.planning/phases/05-websocket-realtime/05-01-SUMMARY.md
@.planning/phases/02-database-schema-types/02-01-SUMMARY.md

# Key files from frontmatter (relevant to this phase):
@server/src/ws/server.ts (after 05-01 conversion)
@server/src/db/schema.ts

**Tech stack available:** TypeScript discriminated unions, Zod for runtime validation
**Established patterns:**
- Use Drizzle ORM inferred types (Match, Commentary)
- Import paths use .js extensions for TypeScript files
- Type-first development with TypeScript compiler validation

**Constraining decisions:**
- [Phase 2-01]: Export inferred types from Drizzle schemas (Match, NewMatch, Commentary, NewCommentary)
- [Phase 5-01]: ExtendedWebSocket interface defined with isAlive and subscriptions properties

**Issues being addressed:** None

**Concerns being verified:**
- Verify message types align with database Match and Commentary types
- Ensure all broadcast messages are type-safe
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WebSocket message type definitions</name>
  <files>server/src/ws/types.ts</files>
  <action>
Create new file server/src/ws/types.ts with message type definitions:

1. **Client → Server messages** (discriminated union):
   type ClientMessage =
     | { type: "subscribe"; matchId: number }
     | { type: "unsubscribe"; matchId: number };

2. **Server → Client messages** (discriminated union):
   type ServerMessage =
     | { type: "welcome" }
     | { type: "subscribed"; matchId: number }
     | { type: "unsubscribed"; matchId: number }
     | { type: "error"; message: string }
     | { type: "match_created"; data: Match }
     | { type: "commentary"; data: Commentary };

3. **Export types** for use in server.ts and for client documentation

4. **Import Match and Commentary types** from db.js (use .js extension)

Rationale: Discriminated unions provide exhaustiveness checking and prevent invalid message types at compile time.
</action>
  <verify>
1. Run npx tsc --noEmit to verify type definitions compile
2. Verify discriminated union types are correctly formed
3. Check Match and Commentary types imported correctly from db.js
</verify>
  <done>
- types.ts created with ClientMessage and ServerMessage discriminated unions
- All message variants defined with correct types
- Match and Commentary types imported from db.js
- TypeScript compilation succeeds
</done>
</task>

<task type="auto">
  <name>Task 2: Update WebSocket server to use message types</name>
  <files>server/src/ws/server.ts</files>
  <action>
Update server.ts to use the new message types:

1. **Import types** from ./types.js:
   import type { ClientMessage, ServerMessage } from "./types.js";

2. **Type message parsing** in handleMessage():
   - Parse JSON to unknown first
   - Type guard to check if message is ClientMessage
   - Handle subscribe/unsubscribe with proper typing

3. **Update broadcast functions** to use ServerMessage type:
   - broadcastMatchCreated: Use ServerMessage type for payload
   - broadcastCommentary: Use ServerMessage type for payload
   - sendJson: Accept ServerMessage parameter
   - broadcastToAll: Accept ServerMessage parameter

4. **Update function signatures**:
   - sendJson(socket: ExtendedWebSocket, payload: ServerMessage): void
   - broadcastToAll(wss: WebSocketServer, payload: ServerMessage): void
   - broadcastToMatch(matchId: number, payload: ServerMessage): void

Do NOT change the runtime behavior - only add type annotations.
</action>
  <verify>
1. Run npx tsc --noEmit to verify TypeScript compilation succeeds
2. Verify all message sending functions use ServerMessage type
3. Verify handleMessage properly validates ClientMessage types
</verify>
  <done>
- All WebSocket functions use ServerMessage type for outbound messages
- ClientMessage type guards validate inbound messages
- Type-safe message contracts enforced at compile time
- No runtime behavior changes
</done>
</task>

<task type="auto">
  <name>Task 3: Update import in index.ts and verify</name>
  <files>server/src/index.ts</files>
  <action>
Update index.ts to verify WebSocket types integrate correctly:

1. **Verify import path** uses .js extension:
   import { attachWebSocketServer } from "./ws/server.js";

2. **Type-check broadcast functions** attached to app.locals:
   - app.locals.broadcastMatchCreated should accept Match parameter
   - app.locals.broadcastCommentary should accept (matchId: number, comment: Commentary) parameters

3. **Verify compilation** - run npx tsc --noEmit to ensure no type errors

No runtime behavior changes - just verification that types integrate correctly.
</action>
  <verify>
1. Run npx tsc --noEmit to verify full project compiles
2. Verify broadcast functions are callable with Match and Commentary types
3. Check server starts with npm run dev
</verify>
  <done>
- index.ts imports from ws/server.js correctly
- Broadcast functions properly typed with Match and Commentary types
- Full project TypeScript compilation succeeds
- Server starts without errors
</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npx tsc --noEmit` passes with no errors in ws/ directory
- [ ] `npx tsc --noEmit` passes with no errors for full project
- [ ] All WebSocket message types defined as discriminated unions
- [ ] Client messages type-checked with type guards
- [ ] Server messages type-checked with ServerMessage type
- [ ] Broadcast functions use Match and Commentary types from db.ts
</verification>

<success_criteria>

- WebSocket message types defined (ClientMessage, ServerMessage)
- All message operations use discriminated union types
- Type-safe client-server communication contracts
- Broadcast functions properly typed
- Full project TypeScript compilation succeeds
- Phase 5 complete
  </success_criteria>

<output>
After completion, create `.planning/phases/05-websocket-realtime/05-02-SUMMARY.md`:

# Phase 5 Plan 2: Message Type Safety Summary

**Added type-safe WebSocket message protocols with discriminated unions for compile-time validation.**

## Accomplishments

- Created ws/types.ts with ClientMessage and ServerMessage discriminated unions
- Updated server.ts to use message types for all operations
- Added type guards for client message validation
- Broadcast functions now enforce ServerMessage type at compile time
- Full project type-safe with no compilation errors

## Files Created/Modified

- `server/src/ws/types.ts` - New file with message type definitions
- `server/src/ws/server.ts` - Updated to use message types
- `server/src/index.ts` - Verified integration

## Decisions Made

[Document any new decisions made during execution]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Phase 5 complete! All WebSocket and real-time code converted to TypeScript with:
- Type-safe WebSocket server implementation
- Discriminated union message types
- Compile-time contract validation
- Integration with database Match and Commentary types

Ready for Phase 6: Performance Profiling
</output>
