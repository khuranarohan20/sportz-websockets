---
phase: 05-websocket-realtime
type: execute
plan: 01
---

<objective>
Convert WebSocket server implementation to TypeScript with proper type annotations for ws library integration and Arcjet security.

Purpose: Complete TypeScript migration of real-time layer by adding type safety to WebSocket connection handling, subscription management, and message broadcasting.

Output: Fully typed `server/src/ws/server.ts` with type-safe WebSocket operations, Arcjet integration, and broadcast functions.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/phase-prompt.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Auto-selected based on dependency graph (from frontmatter):
@.planning/phases/03-core-application-types/03-02-SUMMARY.md
@.planning/phases/04-api-routes-middleware/04-03-SUMMARY.md

# Key files from frontmatter (relevant to this phase):
@server/src/ws/server.js
@server/src/config/arcjet.ts
@server/src/constants/ws.ts
@server/src/routes/matches.ts
@server/src/routes/commentary.ts

**Tech stack available:** ws 8.19.0 (native TypeScript types), @arcjet/node 1.0.0-beta.11, Express 5.2.1
**Established patterns:**
- Express middleware: Promise<void> return type with void returns
- Use .js extensions in import paths for TypeScript files (ES module standard)
- Arcjet types inferred from arcjet() function return value
- Constants with explicit number types

**Constraining decisions:**
- [Phase 3-02]: Let TypeScript infer ArcjetNode type from arcjet() function (@arcjet/node doesn't export ArcjetClient explicitly)
- [Phase 3-02]: Middleware return type must be Promise<void> with proper early returns (not Response objects)
- [Phase 3-02]: Use .js extensions in import paths for TypeScript files
- [Phase 4-03]: Express handlers use Request/Response types with Promise<void> return type

**Issues being addressed:** None

**Concerns being verified:**
- [Phase 4-03]: All API routes converted to TypeScript - verify WebSocket types align with Match/Commentary types
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert WebSocket server to TypeScript</name>
  <files>server/src/ws/server.ts</files>
  <action>
Rename server.js to server.ts and add comprehensive type annotations:

1. **ws library types** - Import WebSocket, WebSocketServer from 'ws' (native types)
2. **Subscriber Map** - Type as Map<number, Set<WebSocket>> for match subscriptions
3. **Function parameters** - Add type annotations:
   - subscribe(matchId: number, socket: ExtendedWebSocket): void
   - unsubscribe(matchId: number, socket: ExtendedWebSocket): void
   - cleanupSubscriptions(socket: ExtendedWebSocket): void
   - broadcastToMatch(matchId: number, payload: Record<string, unknown>): void
   - sendJson(socket: ExtendedWebSocket, payload: Record<string, unknown>): void
   - broadcastToAll(wss: WebSocketServer, payload: Record<string, unknown>): void
   - handleMessage(socket: ExtendedWebSocket, data: Buffer): void
   - attachWebSocketServer(server: http.Server): BroadcastFunctions

4. **Extended WebSocket interface** - Create interface extending WebSocket:
   interface ExtendedWebSocket extends WebSocket {
     isAlive?: boolean;
     subscriptions: Set<number>;
   }

5. **Broadcast functions return type** - Define interface:
   interface BroadcastFunctions {
     broadcastMatchCreated(match: Match): void;
     broadcastCommentary(matchId: number, comment: Commentary): void;
   }

6. **Message handling** - Type message as unknown with type guards:
   - Check message?.type === "subscribe" && Number.isInteger(message?.matchId)
   - Check message?.type === "unsubscribe" && Number.isInteger(message?.matchId)

7. **Update imports**:
   - Change arcjet.js import to .js extension (ES module standard)
   - Change constants/ws.ts import to .js extension
   - Import Match and Commentary types from db.js

8. **Import http module** - Add import for http.Server type from 'http'

Do NOT create custom types for ws library - use native WebSocket types from 'ws' package.
</action>
  <verify>
1. Run npx tsc --noEmit to verify TypeScript compilation succeeds
2. Verify all WebSocket operations are properly typed
3. Check import paths use .js extensions for TypeScript files
</verify>
  <done>
- server.ts renamed and fully typed
- WebSocket connection handling type-safe
- Arcjet security integration typed correctly
- Broadcast functions properly typed with Match/Commentary types
- All TypeScript compilation checks pass
</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npx tsc --noEmit` passes with no errors
- [ ] All WebSocket functions have proper type annotations
- [ ] Import paths use .js extensions for TypeScript files
- [ ] Match and Commentary types imported from db.js
- [ ] Extended WebSocket interface defined for isAlive and subscriptions
</verification>

<success_criteria>

- WebSocket server converted to TypeScript
- All function parameters and return values typed
- Extended WebSocket interface for custom properties
- Broadcast functions use Match and Commentary types from db.ts
- Arcjet integration types correctly inferred
- No TypeScript compilation errors
  </success_criteria>

<output>
After completion, create `.planning/phases/05-websocket-realtime/05-01-SUMMARY.md`:

# Phase 5 Plan 1: WebSocket Server Summary

**Converted WebSocket server implementation to TypeScript with type-safe ws library integration and Arcjet security.**

## Accomplishments

- Renamed ws/server.js to server.ts with comprehensive type annotations
- Added ExtendedWebSocket interface for custom properties (isAlive, subscriptions)
- Typed all subscription management functions
- Typed message handling with proper type guards
- Integrated Match and Commentary types from db.ts for broadcast functions
- Used native WebSocket types from ws library (no custom types needed)

## Files Created/Modified

- `server/src/ws/server.ts` - Converted from .js with full type safety
- `server/src/index.ts` - Update import to use .js extension

## Decisions Made

[Document any new decisions made during execution]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

[If more plans in this phase: "Ready for 05-02-PLAN.md"]
[If phase complete: "Phase complete, ready for Phase 6: Performance Profiling"]
</output>
